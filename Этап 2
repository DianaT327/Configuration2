import xml.etree.ElementTree as ET
import sys
import os
import urllib.request
import urllib.error
import gzip
import tarfile
from io import BytesIO

def parse_config(config_path):
    """Парсит конфигурационный файл XML и возвращает параметры"""
    try:
        if not os.path.exists(config_path):
            raise ValueError(f"Конфигурационный файл не найден: {config_path}")

        tree = ET.parse(config_path)
        root = tree.getroot()

        config = {}

        # Имя анализируемого пакета
        package_name_elem = root.find('package_name')
        if package_name_elem is None or not package_name_elem.text:
            raise ValueError("Отсутствует обязательный параметр: package_name")
        config['package_name'] = package_name_elem.text

        # URL-адрес репозитория или путь к файлу
        repository_url_elem = root.find('repository_url')
        if repository_url_elem is None or not repository_url_elem.text:
            raise ValueError("Отсутствует обязательный параметр: repository_url")
        config['repository_url'] = repository_url_elem.text

        # Режим работы с тестовым репозиторием
        test_repo_mode_elem = root.find('test_repo_mode')
        if test_repo_mode_elem is not None and test_repo_mode_elem.text:
            config['test_repo_mode'] = test_repo_mode_elem.text
        else:
            config['test_repo_mode'] = 'local'

        # Версия пакета
        package_version_elem = root.find('package_version')
        if package_version_elem is not None and package_version_elem.text:
            config['package_version'] = package_version_elem.text
        else:
            config['package_version'] = '1.0.0'

        # Режим вывода зависимостей в формате ASCII-дерева
        ascii_tree_output_elem = root.find('ascii_tree_output')
        if ascii_tree_output_elem is not None and ascii_tree_output_elem.text:
            config['ascii_tree_output'] = ascii_tree_output_elem.text.lower() == 'true'
        else:
            config['ascii_tree_output'] = False

        return config

    except ET.ParseError as e:
        raise ValueError(f"Ошибка парсинга XML: {e}")
    except Exception as e:
        raise ValueError(f"Ошибка загрузки конфигурации: {e}")

def download_and_parse_apkindex(repository_url):
    """Скачивает и парсит APKINDEX.tar.gz"""
    try:
        # 1. Формируем URL
        if repository_url.endswith('/'):
            apkindex_url = repository_url + 'APKINDEX.tar.gz'
        else:
            apkindex_url = repository_url + '/APKINDEX.tar.gz'

        print(f"Скачиваем {apkindex_url}...")

        # 2. Качаем файл
        with urllib.request.urlopen(apkindex_url) as response:
            apkindex_data = response.read()

        print("Файл скачан, распаковываем...")

        # 3. Распаковываем .tar.gz
        with gzip.GzipFile(fileobj=BytesIO(apkindex_data)) as gz_file:
            tar_data = gz_file.read()

        # 4. Читаем tar архив
        with tarfile.open(fileobj=BytesIO(tar_data)) as tar:
            # В tar архиве один файл - APKINDEX
            apkindex_file = tar.extractfile('APKINDEX')
            apkindex_content = apkindex_file.read().decode('utf-8')

        return apkindex_content

    except Exception as e:
        raise ValueError(f"Ошибка при загрузке APKINDEX: {e}")

def find_package_dependencies(apkindex_content, package_name, package_version):
    """Ищет зависимости пакета в APKINDEX"""
    lines = apkindex_content.split('\n')

    current_package = None
    in_target_package = False
    dependencies = []

    for line in lines:
        if line.startswith('P:'):  # Название пакета
            current_package = line[2:]  # Убираем 'P:'
            in_target_package = (current_package == package_name)

        elif line.startswith('V:'):  # Версия пакета
            if in_target_package and package_version and line[2:] != package_version:
                in_target_package = False  # Версия не совпадает

        elif line.startswith('D:') and in_target_package:  # Зависимости
            deps_line = line[2:]  # Убираем 'D:'
            if deps_line:  # Если зависимости есть
                # Разбиваем по пробелам и убираем пустые
                dependencies = [dep.strip() for dep in deps_line.split() if dep.strip()]
                break  # Нашли зависимости, выходим

    return dependencies

def get_alpine_dependencies(package_name, package_version, repository_url):
    """
    Получает прямые зависимости пакета Alpine Linux
    """
    try:
        print(f"Получаем зависимости для пакета: {package_name}-{package_version}")
        print(f"Из репозитория: {repository_url}")

        # 1. Скачиваем и парсим APKINDEX
        apkindex_content = download_and_parse_apkindex(repository_url)

        # 2. Ищем зависимости нашего пакета
        dependencies = find_package_dependencies(apkindex_content, package_name, package_version)

        if not dependencies:
            print(f"Пакет {package_name} не найден в репозитории или не имеет зависимостей")

        return dependencies

    except urllib.error.URLError as e:
        raise ValueError(f"Ошибка при обращении к репозиторию: {e}")
    except Exception as e:
        raise ValueError(f"Ошибка при получении зависимостей: {e}")

def display_parameters(config):
    """Выводит все параметры в формате ключ-значение"""
    print("Параметры конфигурации:")
    for key, value in config.items():
        print(f"{key}: {value}")

def display_dependencies(package_name, dependencies):
    """Выводит прямые зависимости пакета"""
    print(f"\nПрямые зависимости пакета {package_name}:")
    if dependencies:
        for i, dep in enumerate(dependencies, 1):
            print(f"{i}. {dep}")
    else:
        print("Зависимости не найдены")

def main():
    """Основная функция приложения"""
    if len(sys.argv) != 2:
        print("Использование: python main.py <config.xml>")
        sys.exit(1)

    config_path = sys.argv[1]  # ИСПРАВИЛ: переименовал переменную чтобы не конфликтовало

    try:
        # Этап 1: Загрузка конфигурации
        config = parse_config(config_path)  # ИСПРАВИЛ: используем config_path
        display_parameters(config)

        # Этап 2: Получение зависимостей
        print("\n")

        dependencies = get_alpine_dependencies(
            config['package_name'],
            config['package_version'],
            config['repository_url']
        )

        display_dependencies(config['package_name'], dependencies)

    except ValueError as e:
        print(f"Ошибка: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Неожиданная ошибка: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
